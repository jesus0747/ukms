class u{constructor(){this.currentUser=null,this.auth={signIn:async(e,t)=>{const s=await this.hashPassword(t);for(const[n,r]of this.storage.users.entries())if(r.netId===e&&r.passwordHash===s){if(!r.active)throw new Error("User account is disabled");const{passwordHash:a,...o}=r;return this.currentUser=o,{user:this.currentUser}}throw new Error("Invalid credentials")},signOut:async()=>{this.currentUser=null},createUser:async(e,t,s)=>{const n=await this.hashPassword(t),r=this.generateId(),a={id:r,netId:e,email:s,fullName:"",role:"basic_user",active:!0,campusIds:[],temporaryPassword:!0,createdAt:new Date().toISOString(),updatedAt:new Date().toISOString()};return this.storage.users.set(r,{...a,passwordHash:n}),a},updatePassword:async(e,t)=>{const s=this.storage.users.get(e);if(!s)throw new Error("User not found");const n=await this.hashPassword(t);s.passwordHash=n,s.temporaryPassword=!1,s.updatedAt=new Date().toISOString(),this.storage.users.set(e,s)},getCurrentUser:async()=>this.currentUser},this.users={getAll:async()=>Array.from(this.storage.users.values()).map(({passwordHash:e,...t})=>t),getById:async e=>{const t=this.storage.users.get(e);if(!t)return null;const{passwordHash:s,...n}=t;return n},getByNetId:async e=>{for(const[t,s]of this.storage.users.entries())if(s.netId===e){const{passwordHash:n,...r}=s;return r}return null},create:async e=>{const t=this.generateId(),s={id:t,netId:e.netId,fullName:e.fullName||"",email:e.email||"",role:e.role||"basic_user",active:e.active!==void 0?e.active:!0,campusIds:e.campusIds||[],temporaryPassword:e.temporaryPassword!==void 0?e.temporaryPassword:!0,createdAt:new Date().toISOString(),updatedAt:new Date().toISOString()};return this.storage.users.set(t,{...s,passwordHash:""}),s},update:async(e,t)=>{const s=this.storage.users.get(e);if(!s)throw new Error("User not found");Object.assign(s,t,{updatedAt:new Date().toISOString()}),this.storage.users.set(e,s)},delete:async e=>{this.storage.users.delete(e)},count:async()=>this.storage.users.size},this.campuses={getAll:async()=>Array.from(this.storage.campuses.values()),getById:async e=>this.storage.campuses.get(e)||null,create:async e=>{const t=this.generateId(),s={id:t,name:e.name,code:e.code,address:e.address||"",active:e.active!==void 0?e.active:!0,createdAt:new Date().toISOString(),updatedAt:new Date().toISOString()};return this.storage.campuses.set(t,s),s},update:async(e,t)=>{const s=this.storage.campuses.get(e);if(!s)throw new Error("Campus not found");Object.assign(s,t,{updatedAt:new Date().toISOString()}),this.storage.campuses.set(e,s)},delete:async e=>{this.storage.campuses.delete(e)}},this.buildings={getAll:async()=>Array.from(this.storage.buildings.values()),getByCampusId:async e=>Array.from(this.storage.buildings.values()).filter(t=>t.campusId===e),getById:async e=>this.storage.buildings.get(e)||null,create:async e=>{const t=this.generateId(),s={id:t,name:e.name,code:e.code,campusId:e.campusId,address:e.address||"",active:e.active!==void 0?e.active:!0,createdAt:new Date().toISOString(),updatedAt:new Date().toISOString()};return this.storage.buildings.set(t,s),s},update:async(e,t)=>{const s=this.storage.buildings.get(e);if(!s)throw new Error("Building not found");Object.assign(s,t,{updatedAt:new Date().toISOString()}),this.storage.buildings.set(e,s)},delete:async e=>{this.storage.buildings.delete(e)}},this.keySystems={getAll:async()=>Array.from(this.storage.keySystems.values()),getById:async e=>this.storage.keySystems.get(e)||null,create:async e=>{const t=this.generateId(),s={id:t,name:e.name,brand:e.brand,campusId:e.campusId,description:e.description||"",active:e.active!==void 0?e.active:!0,createdAt:new Date().toISOString(),updatedAt:new Date().toISOString()};return this.storage.keySystems.set(t,s),s},update:async(e,t)=>{const s=this.storage.keySystems.get(e);if(!s)throw new Error("Key system not found");Object.assign(s,t,{updatedAt:new Date().toISOString()}),this.storage.keySystems.set(e,s)},delete:async e=>{this.storage.keySystems.delete(e)}},this.keys={getAll:async()=>Array.from(this.storage.keys.values()),getById:async e=>this.storage.keys.get(e)||null,getBySystemId:async e=>Array.from(this.storage.keys.values()).filter(t=>t.keySystemId===e),getByBuildingId:async e=>Array.from(this.storage.keys.values()).filter(t=>t.buildingId===e),create:async e=>{const t=this.generateId(),s={id:t,keyNumber:e.keyNumber,keySystemId:e.keySystemId,buildingId:e.buildingId,roomNumber:e.roomNumber||"",status:e.status||"available",medecoKeyNumber:e.medecoKeyNumber||null,medecoKeySerial:e.medecoKeySerial||null,medecoCardNumber:e.medecoCardNumber||null,notes:e.notes||"",createdAt:new Date().toISOString(),updatedAt:new Date().toISOString()};return this.storage.keys.set(t,s),s},update:async(e,t)=>{const s=this.storage.keys.get(e);if(!s)throw new Error("Key not found");Object.assign(s,t,{updatedAt:new Date().toISOString()}),this.storage.keys.set(e,s)},delete:async e=>{this.storage.keys.delete(e)},search:async e=>{const t=e.toLowerCase();return Array.from(this.storage.keys.values()).filter(s=>{var n,r,a;return s.keyNumber.toLowerCase().includes(t)||((n=s.roomNumber)==null?void 0:n.toLowerCase().includes(t))||((r=s.medecoKeyNumber)==null?void 0:r.toLowerCase().includes(t))||((a=s.notes)==null?void 0:a.toLowerCase().includes(t))})}},this.keyHistory={getAll:async()=>Array.from(this.storage.keyHistory.values()),getByKeyId:async e=>Array.from(this.storage.keyHistory.values()).filter(t=>t.keyId===e),getByUserId:async e=>Array.from(this.storage.keyHistory.values()).filter(t=>t.userId===e),getActiveCheckouts:async()=>Array.from(this.storage.keyHistory.values()).filter(e=>e.action==="checkout"&&!e.actualReturnDate),getById:async e=>this.storage.keyHistory.get(e)||null,create:async e=>{const t=this.generateId(),s={id:t,keyId:e.keyId,userId:e.userId,action:e.action,checkoutDate:e.checkoutDate||null,expectedReturnDate:e.expectedReturnDate||null,actualReturnDate:e.actualReturnDate||null,notes:e.notes||"",createdAt:new Date().toISOString()};return this.storage.keyHistory.set(t,s),s},update:async(e,t)=>{const s=this.storage.keyHistory.get(e);if(!s)throw new Error("Key history not found");Object.assign(s,t),this.storage.keyHistory.set(e,s)}},this.auditLogs={getAll:async()=>Array.from(this.storage.auditLogs.values()),getByUserId:async e=>Array.from(this.storage.auditLogs.values()).filter(t=>t.userId===e),create:async e=>{const t=this.generateId(),s={id:t,userId:e.userId,action:e.action,entityType:e.entityType,entityId:e.entityId||null,description:e.description,metadata:e.metadata||null,createdAt:new Date().toISOString()};return this.storage.auditLogs.set(t,s),s}},this.backup={export:async()=>({users:Array.from(this.storage.users.entries()),campuses:Array.from(this.storage.campuses.entries()),buildings:Array.from(this.storage.buildings.entries()),keySystems:Array.from(this.storage.keySystems.entries()),keys:Array.from(this.storage.keys.entries()),keyHistory:Array.from(this.storage.keyHistory.entries()),auditLogs:Array.from(this.storage.auditLogs.entries())}),import:async e=>{e.users&&(this.storage.users=new Map(e.users)),e.campuses&&(this.storage.campuses=new Map(e.campuses)),e.buildings&&(this.storage.buildings=new Map(e.buildings)),e.keySystems&&(this.storage.keySystems=new Map(e.keySystems)),e.keys&&(this.storage.keys=new Map(e.keys)),e.keyHistory&&(this.storage.keyHistory=new Map(e.keyHistory)),e.auditLogs&&(this.storage.auditLogs=new Map(e.auditLogs))}},this.storage={users:new Map,campuses:new Map,buildings:new Map,keySystems:new Map,keys:new Map,keyHistory:new Map,auditLogs:new Map}}async initialize(e){console.log("MySQL adapter initialized (in-memory mode)")}async hashPassword(e){const s=new TextEncoder().encode(e),n=await crypto.subtle.digest("SHA-256",s);return Array.from(new Uint8Array(n)).map(r=>r.toString(16).padStart(2,"0")).join("")}generateId(){return`${Date.now()}-${Math.random().toString(36).substr(2,9)}`}}export{u as MySQLAdapter};
